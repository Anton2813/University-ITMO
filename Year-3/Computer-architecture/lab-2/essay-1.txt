С каждым годом становится все больше и больше пользователей различной компьютерной техники. В следствие этого возникает вопрос, как же сделать так, чтобы ни у кого ничего не сломалось, или как бы не нашлась уязвимость, из-за которой могут пострадать огромное число пользователей. Как результат мы видим, что тенденция создания чего-то кардинально нового с каждым годом еще больше усугубляется.

В первую очередь хотелось бы начать с архитектур процессоров. Как мы знаем, в наше время преобладает архитектура фон Неймана, и почти все процессоры на x86, arm, risk. На лекциях нам рассказывали, что уже долгое время затраты на разработку железа по сравнению с разработкой программного обеспечения растут более медленно, если даже не растут совсем. Мне кажется, что это связано с тем, что, так как эти архитектуры уже были разработаны давно, они являются довольно надежными, а разработка чего-то нового очень дорогостоящая и не факт что осмысленная.

На момент 1974 года обладателями компьютеров являлись лишь тысячи человек, шли активные разработки, чтобы сделать все как можно лучше. В то время даже можно было не заморачивались над поддержкой различного программного обеспечения, так как не было операционной системы и все задачи писались под конкретные машины (если надо - напиши свой компилятор или транслятор ассемблера в машинные команды). В общем люди даже и не задумывались над использованием одного ПО на разных компьютерах, так как все было написано под определенное железо, а самих пользователей было мало - различные компании и богатые люди, да и только.

Сейчас же пользователей очень много, потому что компьютеры стали мощнее, на них уменьшилась цена, уже было написано очень много полезного ПО. Большинство организаций теперь имеют сервера и системы, работающие десятки лет (можете сходить в поликлинику и увидеть, что на некоторых компьютерах до сих пор стоит Windows XP). Следовательно, возникает необходимость обратной совместимости. Тут мы плавно перетекаем к выступлению Марка Рендела, где он на примере Visual Basic рассказывал, как из-за нее в языке появлялась конструкция and also, or else, которая как бы делала этот язык "лучше" (к этому мы еще вернемся), но при этом казалось бы, почему просто не заменить старую семантику на новую? Это и есть проблема обратной совместимости. Она возникает в тех случаях, когда мы не может использовать старую версию ПО (например, мы обновили Windows 7 на Windows 10, и мы даже не думаем что что-то может сломаться, какие-то приложения не смогут запуститься).

Что же я всем этим хочу сказать? В первую очередь то, что сейчас невероятно трудно что-то уже поменять, так как после создания чего-то нового, нам придется делать так, чтобы этим новым начали пользоваться другие люди, а для этого нужно будет переписать большую часть программного обеспечения, уже написанного под другие архитектуры компьютера, операционные системы и т.д. Однако никто этим заниматься в здравом уме за бесплатно не будет, такова уж современная жизнь: нет пользователей - нет финансирования - нет разработки.

Также хотелось бы добавить пару слов о втором видео, в частности о различных конструкциях языков программирования. Например, у нас есть unless в perl. Большинство разработчиков, которые пришли из других языков программирования, где есть конструкция if else, привычная большинству, скажут, что это странно. Тоже самое касается и языка GO, где вместо стандартного паттерна для написания формата дат используется Mon Jan 2 15:04:05 MST 2006. Однако если вашим первым языком программирования был бы либо perl, либо GO, то, скорее всего, ничего странного, в этих вещах вы бы не увидели.

Как итог, мне кажется, что проблема того, что уже десяток лет мы топчемся на одном месте в плане развития - обратная совместимость как железа и программного обеспечения, написанного для него, так и людей, которые уже привыкли к чему-то одному и не хотят меняться. Однако от этого груза так просто не избавиться. Безусловно, мы должны меняться, но для этого придется начинать все "почти сначала", но уже с упором на полученные знания.
