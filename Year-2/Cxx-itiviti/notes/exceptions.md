## Ретроспектива второго задания

### Как обрабатывать ошибки аллокации

```c++
void * realloc_nofail(void * ptr, size_t size) {
  if (void * new_ptr = realloc(ptr, size)) {
    return new_ptr;
  } else {
    std::abort();   // роняем приложение
    // или думать что мы можем сделать в случае если кончилась память
  }
}
```

### std::move

После мува корректно будут работать функции без pre-conditions, с conditions не специфицированы.
Например `empty()` имеет pre-conditions, а `clear()` не имеет.

## Исключения

* Не везде нужно возвращать значения
* Значение нужно явно прокинуть через весь стек вызовов к месту, где ошибку можно обработать
* Возвращаемые значения можно игнорировать
* Из некоторых функций нельзя ничего вернуть

</br>

* Исключения нельзя игнорировать
* Исключение можно выбросить в любом месте
* В некоторых местах нельзя обработать выброшенные исключения, в таком случае, программа завершится вызовом std::terminate()
* Исключения можно обрабатывать в любом месте по стеку вызовов

```c++
try {
    // sequence of one or more possibly throwing statements
} catch (T e) {
    // exception handler for type T
} catch (T) {
    // same, but with no access to exception object
} catch (...) {
    // exception handler for any exception, не имеет доступа
    // есть магия, через которую можно обратиться
}
```

```c++
try {
    // sequence of one or more possibly throwing statements
} catch (T1 e) {
    // value
} catch (T2 & e) {
    // reference
} catch (T3 * e) {
    // pointer, могут быть проблемы с определением типа
}
```

### Выбор подходящего обработчика

* последовательно в блоке try-catch, от первого к последнему
обработчик “подходит”, если:
  * тип исключения совпадает с типом параметра обработчика (без cv - const volatile)
  * параметр обработчика - ссылка на тип исключения (без cv)
  * параметр обработчика - базовый класс типа исключения
  * параметр обработчика - ссылка на базовый класс типа исключения
  * тип исключения и параметр обработчика - “совместимые” указатели
  * тип исключения - std::nullptr_t, параметр обработчика - указатель
  * параметр обработчика - ...
* если подходящего обработчика нет, поиск повторяется уровнем выше (вложенные try-catch)
* если уровня выше нет, программа завершается вызовом std::terminate()

### Безопасность исключений

* Логика вашего кода может не ожидать внезапной остановки в середине выполнения
* Не во всем коде можно использовать исключения

Рассмотрим первое:
```c++
File & operator=(const File & rhs)
{
    if (this == &rhs) { return *this; }
    m_stream = rhs.m_stream;
    m_name = rhs.name;  // throws
    return *this;
}

File f1{“f1.txt”}, f2{“f2.txt”};
try {
    f1 = f2;
} catch (...) {
    // log error
}
```

#### Copy-and-swap
```c++
File & operator=(const File & rhs)
{
    if (this == &rhs) { return *this; }
    File tmp(rhs); // throws? who cares
    swap(tmp);
    return *this;
}
```

#### Move and swap
```c++
File & operator=(File && rhs)
{
    if (this == &rhs) { return *this; }
    File tmp(std::move(rhs)); // throws? who cares
    swap(tmp);
    return *this;
}
```

#### Гарантии безопасности исключений
* __гарантия отсутствия исключений__ - функция не выбросит исключение ни при каких обстоятельствах
* __сильная гарантия__ - если из функции было выброшено исключение, программа возвращается в состояние до вызова функции (copy-and-swap, move-and-swap)
* __слабая гарантия__ - если из функции было выброшено исключение, программа находится в валидном состоянии (может быть в другом)
* __никаких гарантий__

> По умолчанию в std сильная гарантия, где задокументировано - слабая, если нет гарантий, то можно вызывать std::terminate.

<br/>

Нельзя выбрасывать исключение, когда уже обрабатывается другое исключение __при разматывании стека__. По этой причине не рекомендуется
выбрасывать исключения в деструкторах (при разматывании вызовется std::terminate).

### noexcept

* Спецификатор который говорит о том что функция не бросает исключения
* Не проверяется компилятором, но проверяется рантаймом
* Если noexcept-функция бросит исключение во время выполнения, программа завершится std::terminate()

```c++
void foo() noexcept;
```
#### noexcept(condition)
* noexcept может зависеть от какого-либо условия времени компиляции
```c++
template<typename T>
T div(T arg) noexcept(std::is_floating_point_v<T>);
```

> noexcept при std::move() вектора

> Деструкторы по умолчанию noexcept

### Механизм работы исключений в C++

* Описывается ABI и зависит от конкретной платформы
* Исключения бесплатные если они не выбрасываются, и дорогие если их приходится обрабатывать
* Исключения не рекомендуется использовать для обработки ошибок там, где ошибки случаются часто
* Для x86-64 Linux: [C++ ABI for Itanium: Exception Handling](https://itanium-cxx-abi.github.io/cxx-abi/abi-eh.html)

#### Подходы обработки исключений
* На месте возможного выброса исключения генерируется код, и затем при возникновении он используется. Платим много
за создание самого этого кода, но дешево при появлении исключения.

* На месте не генирируем, но существуют таблицы с адресами с какого по какой может выброшено
исключение (единица таблицы содержит instruction address с и до какого обрабатывается в данной строке таблицы),
и в случае выброса переходим в данные таблицы, ищем запись, которая обрабатывает исключение,
и затем instruction pointer переходит на указанный адрес. 

> В C++ второй тип.
